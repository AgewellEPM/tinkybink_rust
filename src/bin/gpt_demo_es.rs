//! üá™üá∏ Demo de GPT en Espa√±ol - Sistema AAC Inteligente
//!
//! Demuestra el poder del n√∫cleo GPT espa√±ol con:
//! - Procesamiento de lenguaje natural en espa√±ol
//! - Conciencia emocional y cultural
//! - Patrones conversacionales espa√±oles
//! - Integraci√≥n con datos de entrenamiento

use anyhow::Result;
use colored::*;
use serde_json::Value;
use std::fs;
use std::io::{self, Write};
use std::path::Path;
use tinkybink_rust::ai::gpt_core_es::{ConfiguracionGPT, EstadoEmocional, NucleoGPTEspa√±ol};

/// Cargador de datos de entrenamiento espa√±oles
struct CargadorDatosEspa√±ol {
    vocabulario: Vec<String>,
    frases: Vec<Vec<String>>,
    emociones: Vec<EstadoEmocional>,
}

impl CargadorDatosEspa√±ol {
    fn nuevo() -> Result<Self> {
        let mut vocabulario = Vec::new();
        let mut frases = Vec::new();
        let mut emociones = Vec::new();

        // Cargar todos los archivos de entrenamiento espa√±oles
        let dir_entrenamiento = Path::new("training_es");
        if dir_entrenamiento.exists() {
            for entrada in fs::read_dir(dir_entrenamiento)? {
                let entrada = entrada?;
                let ruta = entrada.path();
                if ruta.extension().and_then(|s| s.to_str()) == Some("json") {
                    let contenido = fs::read_to_string(&ruta)?;
                    let datos: Value = serde_json::from_str(&contenido)?;

                    if let Some(nodos) = datos["nodes"].as_array() {
                        for nodo in nodos {
                            // Extraer texto
                            if let Some(texto) = nodo["text"].as_str() {
                                let palabras: Vec<String> = texto.split_whitespace().map(|s| s.to_string()).collect();
                                frases.push(palabras.clone());
                                for palabra in palabras {
                                    if !vocabulario.contains(&palabra) {
                                        vocabulario.push(palabra);
                                    }
                                }
                            }

                            // Extraer emociones
                            if let Some(emocion) = nodo["emotion"].as_object() {
                                let estado = EstadoEmocional {
                                    valencia: emocion.get("valencia").and_then(|v| v.as_f64()).unwrap_or(0.5) as f32,
                                    activacion: emocion.get("activacion").and_then(|v| v.as_f64()).unwrap_or(0.5)
                                        as f32,
                                    dominancia: emocion.get("dominancia").and_then(|v| v.as_f64()).unwrap_or(0.5)
                                        as f32,
                                    expresividad: emocion.get("expresividad").and_then(|v| v.as_f64()).unwrap_or(0.7)
                                        as f32,
                                    pasion: emocion.get("pasion").and_then(|v| v.as_f64()).unwrap_or(0.6) as f32,
                                };
                                emociones.push(estado);
                            }
                        }
                    }
                }
            }
        }

        // Si no hay datos, usar ejemplos por defecto
        if vocabulario.is_empty() {
            vocabulario = vec![
                "Hola", "Buenos", "d√≠as", "¬øC√≥mo", "est√°s?", "Muy", "bien", "gracias", "Por", "favor", "Necesito",
                "ayuda", "Tengo", "hambre", "sed", "Me", "duele", "Quiero", "jugar", "mam√°", "pap√°", "escuela", "casa",
                "amigo", "feliz", "triste", "¬°Ol√©!", "¬°Vamos!", "¬øQu√©", "tal?", "Adi√≥s", "Hasta", "luego",
            ]
            .iter()
            .map(|s| s.to_string())
            .collect();
        }

        Ok(Self { vocabulario, frases, emociones })
    }

    fn tokenizar(&self, texto: &str) -> Vec<usize> {
        texto.split_whitespace().filter_map(|palabra| self.vocabulario.iter().position(|v| v == palabra)).collect()
    }

    fn detokenizar(&self, tokens: &[usize]) -> String {
        tokens.iter().filter_map(|&idx| self.vocabulario.get(idx)).cloned().collect::<Vec<_>>().join(" ")
    }
}

/// Demo interactiva principal
fn ejecutar_demo() -> Result<()> {
    println!("{}", "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó".cyan());
    println!("{}", "‚ïë     üá™üá∏ TINKYBINK GPT ESPA√ëOL - SISTEMA AAC INTELIGENTE    ‚ïë".cyan().bold());
    println!("{}", "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù".cyan());
    println!();

    // Cargar datos de entrenamiento
    println!("{} Cargando datos de entrenamiento espa√±oles...", "‚Üí".green());
    let cargador = CargadorDatosEspa√±ol::nuevo()?;
    println!("{} Vocabulario: {} palabras", "‚úì".green(), cargador.vocabulario.len());
    println!("{} Frases de entrenamiento: {}", "‚úì".green(), cargador.frases.len());
    println!("{} Estados emocionales: {}", "‚úì".green(), cargador.emociones.len());
    println!();

    // Configurar el modelo
    let config = ConfiguracionGPT {
        tama√±o_vocabulario: cargador.vocabulario.len().max(1000),
        dim_oculta: 256,
        num_capas: 6,
        num_cabezas: 8,
        longitud_contexto: 512,
        tasa_abandono: 0.1,
        temp_emocional: 0.8,
    };

    println!("{} Inicializando n√∫cleo GPT espa√±ol...", "‚Üí".yellow());
    let mut modelo = NucleoGPTEspa√±ol::nuevo(config);
    println!("{} ¬°Modelo listo!", "‚úì".green().bold());
    println!();

    // Men√∫ de demostraci√≥n
    loop {
        println!("{}", "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê".magenta());
        println!("{}", "‚îÇ       MEN√ö DE DEMOSTRACI√ìN          ‚îÇ".magenta().bold());
        println!("{}", "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§".magenta());
        println!("{}", "‚îÇ 1. Generar saludo espa√±ol           ‚îÇ".magenta());
        println!("{}", "‚îÇ 2. Expresar necesidad b√°sica        ‚îÇ".magenta());
        println!("{}", "‚îÇ 3. Mostrar emoci√≥n cultural         ‚îÇ".magenta());
        println!("{}", "‚îÇ 4. Conversaci√≥n interactiva         ‚îÇ".magenta());
        println!("{}", "‚îÇ 5. Demostraci√≥n de pasi√≥n espa√±ola  ‚îÇ".magenta());
        println!("{}", "‚îÇ 6. Emergencia m√©dica                ‚îÇ".magenta());
        println!("{}", "‚îÇ 0. Salir                            ‚îÇ".magenta());
        println!("{}", "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò".magenta());

        print!("\n{} Elige una opci√≥n: ", "‚Üí".cyan());
        io::stdout().flush()?;

        let mut entrada = String::new();
        io::stdin().read_line(&mut entrada)?;

        match entrada.trim() {
            "1" => demostrar_saludo(&mut modelo, &cargador)?,
            "2" => demostrar_necesidad(&mut modelo, &cargador)?,
            "3" => demostrar_emocion(&mut modelo, &cargador)?,
            "4" => conversacion_interactiva(&mut modelo, &cargador)?,
            "5" => demostrar_pasion(&mut modelo, &cargador)?,
            "6" => demostrar_emergencia(&mut modelo, &cargador)?,
            "0" => {
                println!("\n{} ¬°Adi√≥s! ¬°Hasta la vista!", "üëã".to_string().yellow());
                break;
            }
            _ => println!("{} Opci√≥n no v√°lida", "‚úó".red()),
        }

        println!();
    }

    Ok(())
}

fn demostrar_saludo(modelo: &mut NucleoGPTEspa√±ol, cargador: &CargadorDatosEspa√±ol) -> Result<()> {
    println!("\n{}", "=== GENERACI√ìN DE SALUDO ESPA√ëOL ===".green().bold());

    // Establecer estado emocional alegre y expresivo
    modelo.actualizar_emocion(EstadoEmocional {
        valencia: 0.9,
        activacion: 0.7,
        dominancia: 0.6,
        expresividad: 0.9,
        pasion: 0.8,
    });

    let prompts = vec!["Buenos", "Hola", "¬øQu√©"];

    for prompt in prompts {
        let tokens = cargador.tokenizar(prompt);
        if !tokens.is_empty() {
            let generado = modelo.generar(&tokens, 5)?;
            let texto = cargador.detokenizar(&generado);
            println!("{} {} ‚Üí {}", "üí¨".to_string(), prompt.yellow(), texto.green());
        }
    }

    Ok(())
}

fn demostrar_necesidad(modelo: &mut NucleoGPTEspa√±ol, cargador: &CargadorDatosEspa√±ol) -> Result<()> {
    println!("\n{}", "=== EXPRESI√ìN DE NECESIDADES ===".blue().bold());

    // Estado emocional de necesidad
    modelo.actualizar_emocion(EstadoEmocional {
        valencia: 0.3,
        activacion: 0.8,
        dominancia: 0.4,
        expresividad: 0.8,
        pasion: 0.5,
    });

    let necesidades = vec!["Tengo", "Necesito", "Quiero"];

    for necesidad in necesidades {
        let tokens = cargador.tokenizar(necesidad);
        if !tokens.is_empty() {
            let generado = modelo.generar(&tokens, 4)?;
            let texto = cargador.detokenizar(&generado);
            println!("{} {} ‚Üí {}", "üÜò".to_string(), necesidad.yellow(), texto.cyan());
        }
    }

    Ok(())
}

fn demostrar_emocion(modelo: &mut NucleoGPTEspa√±ol, cargador: &CargadorDatosEspa√±ol) -> Result<()> {
    println!("\n{}", "=== EXPRESIONES EMOCIONALES CULTURALES ===".magenta().bold());

    let emociones = vec![
        (
            "Feliz",
            EstadoEmocional { valencia: 1.0, activacion: 0.9, dominancia: 0.7, expresividad: 1.0, pasion: 0.9 },
            "üòÑ",
        ),
        (
            "Triste",
            EstadoEmocional { valencia: 0.1, activacion: 0.3, dominancia: 0.2, expresividad: 0.6, pasion: 0.4 },
            "üò¢",
        ),
        (
            "Apasionado",
            EstadoEmocional { valencia: 0.8, activacion: 1.0, dominancia: 0.9, expresividad: 1.0, pasion: 1.0 },
            "üî•",
        ),
    ];

    for (nombre, emocion, emoji) in emociones {
        modelo.actualizar_emocion(emocion);
        let tokens = cargador.tokenizar("Me");
        if !tokens.is_empty() {
            let generado = modelo.generar(&tokens, 6)?;
            let texto = cargador.detokenizar(&generado);
            println!("{} {} ‚Üí {}", emoji, nombre.yellow(), texto.magenta());
        }
    }

    Ok(())
}

fn conversacion_interactiva(modelo: &mut NucleoGPTEspa√±ol, cargador: &CargadorDatosEspa√±ol) -> Result<()> {
    println!("\n{}", "=== CONVERSACI√ìN INTERACTIVA ===".cyan().bold());
    println!("{}", "Escribe en espa√±ol (o 'salir' para terminar)".italic());

    loop {
        print!("\n{} T√∫: ", "üë§".to_string());
        io::stdout().flush()?;

        let mut entrada = String::new();
        io::stdin().read_line(&mut entrada)?;
        let entrada = entrada.trim();

        if entrada == "salir" {
            break;
        }

        // Analizar emoci√≥n de la entrada
        let emocion = analizar_emocion_entrada(entrada);
        modelo.actualizar_emocion(emocion);

        let tokens = cargador.tokenizar(entrada);
        if !tokens.is_empty() {
            let generado = modelo.generar(&tokens, 8)?;
            let respuesta = cargador.detokenizar(&generado);
            println!("{} TinkyBink: {}", "ü§ñ".to_string(), respuesta.green());
        } else {
            println!("{} TinkyBink: {}", "ü§ñ".to_string(), "No entiendo, ¬øpuedes repetir?".yellow());
        }
    }

    Ok(())
}

fn demostrar_pasion(modelo: &mut NucleoGPTEspa√±ol, cargador: &CargadorDatosEspa√±ol) -> Result<()> {
    println!("\n{}", "=== DEMOSTRACI√ìN DE PASI√ìN ESPA√ëOLA ===".red().bold());

    // M√°xima pasi√≥n y expresividad
    modelo.actualizar_emocion(EstadoEmocional {
        valencia: 0.9,
        activacion: 1.0,
        dominancia: 0.8,
        expresividad: 1.0,
        pasion: 1.0,
    });

    let expresiones = vec!["¬°Ol√©!", "¬°Vamos!", "¬°Qu√©"];

    for expr in expresiones {
        let tokens = cargador.tokenizar(expr);
        if !tokens.is_empty() {
            let generado = modelo.generar(&tokens, 6)?;
            let texto = cargador.detokenizar(&generado);
            println!("{} {} ‚Üí {}", "üíÉ".to_string(), expr.red(), texto.yellow().bold());
        }
    }

    Ok(())
}

fn demostrar_emergencia(modelo: &mut NucleoGPTEspa√±ol, cargador: &CargadorDatosEspa√±ol) -> Result<()> {
    println!("\n{}", "=== SITUACI√ìN DE EMERGENCIA ===".red().bold().on_yellow());

    // Estado de urgencia
    modelo.actualizar_emocion(EstadoEmocional {
        valencia: 0.1,
        activacion: 1.0,
        dominancia: 0.3,
        expresividad: 1.0,
        pasion: 0.9,
    });

    let emergencias = vec!["¬°Ayuda!", "Me duele", "Necesito m√©dico"];

    for emergencia in emergencias {
        let tokens = cargador.tokenizar(emergencia);
        if !tokens.is_empty() {
            let generado = modelo.generar(&tokens, 5)?;
            let texto = cargador.detokenizar(&generado);
            println!("{} {} ‚Üí {}", "üö®".to_string(), emergencia.red().bold(), texto.on_red().white());
        }
    }

    println!("\n{} Llamando al 112...", "üìû".to_string().blink());

    Ok(())
}

fn analizar_emocion_entrada(texto: &str) -> EstadoEmocional {
    let texto_lower = texto.to_lowercase();

    // An√°lisis b√°sico de sentimiento
    let palabras_positivas = ["feliz", "bien", "genial", "estupendo", "alegre", "contento"];
    let palabras_negativas = ["triste", "mal", "dolor", "miedo", "enfadado", "cansado"];
    let palabras_urgentes = ["ayuda", "emergencia", "dolor", "necesito", "urgente"];
    let palabras_pasionales = ["ole", "vamos", "incre√≠ble", "amor", "pasi√≥n"];

    let mut valencia: f32 = 0.5;
    let mut activacion: f32 = 0.5;
    let mut expresividad: f32 = 0.7;
    let mut pasion: f32 = 0.6;

    for palabra in palabras_positivas.iter() {
        if texto_lower.contains(palabra) {
            valencia += 0.2;
            activacion += 0.1;
        }
    }

    for palabra in palabras_negativas.iter() {
        if texto_lower.contains(palabra) {
            valencia -= 0.2;
            activacion += 0.1;
        }
    }

    for palabra in palabras_urgentes.iter() {
        if texto_lower.contains(palabra) {
            activacion = 1.0;
            expresividad = 1.0;
        }
    }

    for palabra in palabras_pasionales.iter() {
        if texto_lower.contains(palabra) {
            pasion = 1.0;
            expresividad = 1.0;
        }
    }

    // Signos de exclamaci√≥n aumentan la expresividad
    let exclamaciones = texto.matches('!').count() as f32;
    expresividad = (expresividad + exclamaciones * 0.1).min(1.0);
    pasion = (pasion + exclamaciones * 0.05).min(1.0);

    EstadoEmocional {
        valencia: valencia.clamp(0.0, 1.0),
        activacion: activacion.clamp(0.0, 1.0),
        dominancia: 0.5,
        expresividad: expresividad.clamp(0.0, 1.0),
        pasion: pasion.clamp(0.0, 1.0),
    }
}

fn main() {
    println!(
        "{}",
        "
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                    ‚ïë
‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó  ‚ïë
‚ïë   ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù  ‚ïë
‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù  ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ïë
‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó   ‚ïö‚ñà‚ñà‚ïî‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó   ‚ïë
‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó  ‚ïë
‚ïë      ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù  ‚ïë
‚ïë                                                                    ‚ïë
‚ïë                  üá™üá∏ GPT ESPA√ëOL - EDICI√ìN ESPECIAL üá™üá∏                ‚ïë
‚ïë                                                                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    "
        .bright_red()
        .bold()
    );

    if let Err(e) = ejecutar_demo() {
        eprintln!("{} Error: {}", "‚úó".red().bold(), e);
        std::process::exit(1);
    }
}
