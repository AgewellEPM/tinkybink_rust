//! ğŸ§ ğŸ’¥ å°å‹æ¨¡å‹çš„GPTæ³¨å…¥æ ¸å¿ƒ - ä¸­æ–‡ç‰ˆ
//! 
//! é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¸ºä»»ä½•å°å‹æ¨¡å‹èµ‹äºˆGPTæ™ºèƒ½ï¼š
//! - å› æœæ³¨æ„åŠ›æµ
//! - ä»¤ç‰Œé¢„æµ‹
//! - ä¸Šä¸‹æ–‡çª—å£
//! - æƒ…æ„Ÿæ˜ å°„

use anyhow::Result;
use std::collections::VecDeque;
use serde::{Serialize, Deserialize};

/// ä¸­æ–‡GPTæ¨¡å‹é…ç½®
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct GPTé…ç½® {
    pub è¯æ±‡é‡å¤§å°: usize,
    pub éšè—å±‚ç»´åº¦: usize,
    pub å±‚æ•°: usize,
    pub æ³¨æ„åŠ›å¤´æ•°: usize,
    pub ä¸Šä¸‹æ–‡é•¿åº¦: usize,
    pub dropoutç‡: f32,
    pub æƒ…æ„Ÿæ¸©åº¦: f32,
}

impl Default for GPTé…ç½® {
    fn default() -> Self {
        Self {
            è¯æ±‡é‡å¤§å°: 60000,  // æ›´å¤§çš„è¯æ±‡é‡æ”¯æŒä¸­æ–‡å­—ç¬¦
            éšè—å±‚ç»´åº¦: 768,
            å±‚æ•°: 12,
            æ³¨æ„åŠ›å¤´æ•°: 12,
            ä¸Šä¸‹æ–‡é•¿åº¦: 1024,
            dropoutç‡: 0.1,
            æƒ…æ„Ÿæ¸©åº¦: 0.6,
        }
    }
}

/// ä¸­æ–‡æƒ…æ„ŸçŠ¶æ€æ™ºèƒ½
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct æƒ…æ„ŸçŠ¶æ€ {
    pub ä»·å€¼æ€§: f32,      // -1.0 (è´Ÿé¢) åˆ° 1.0 (æ­£é¢)
    pub æ¿€æ´»åº¦: f32,      // 0.0 (å¹³é™) åˆ° 1.0 (æ¿€åŠ¨)
    pub ä¸»å¯¼æ€§: f32,      // 0.0 (é¡ºä») åˆ° 1.0 (ä¸»å¯¼)
    pub å«è“„åº¦: f32,      // 0.0 (ç›´æ¥) åˆ° 1.0 (å«è“„) - ä¸­æ–‡ç‰¹å¾
    pub å’Œè°æ€§: f32,      // 0.0 (å¯¹æŠ—) åˆ° 1.0 (å’Œè°) - ä¸­æ–‡æ–‡åŒ–ç‰¹å¾
}

impl Default for æƒ…æ„ŸçŠ¶æ€ {
    fn default() -> Self {
        Self {
            ä»·å€¼æ€§: 0.5,
            æ¿€æ´»åº¦: 0.4,
            ä¸»å¯¼æ€§: 0.3,
            å«è“„åº¦: 0.7,  // ä¸­æ–‡æ–‡åŒ–æ›´å«è“„
            å’Œè°æ€§: 0.8,  // å¼ºè°ƒå’Œè°
        }
    }
}

/// å› æœæ³¨æ„åŠ›å¼•æ“
pub struct æ³¨æ„åŠ›å¼•æ“ {
    æƒé‡_q: Vec<Vec<f32>>,
    æƒé‡_k: Vec<Vec<f32>>,
    æƒé‡_v: Vec<Vec<f32>>,
    æƒé‡_è¾“å‡º: Vec<Vec<f32>>,
    å¤´æ•°: usize,
    å¤´ç»´åº¦: usize,
}

impl æ³¨æ„åŠ›å¼•æ“ {
    pub fn æ–°å»º(éšè—ç»´åº¦: usize, æ³¨æ„åŠ›å¤´æ•°: usize) -> Self {
        let å¤´ç»´åº¦ = éšè—ç»´åº¦ / æ³¨æ„åŠ›å¤´æ•°;
        
        Self {
            æƒé‡_q: Self::åˆå§‹åŒ–æƒé‡(éšè—ç»´åº¦, éšè—ç»´åº¦),
            æƒé‡_k: Self::åˆå§‹åŒ–æƒé‡(éšè—ç»´åº¦, éšè—ç»´åº¦),
            æƒé‡_v: Self::åˆå§‹åŒ–æƒé‡(éšè—ç»´åº¦, éšè—ç»´åº¦),
            æƒé‡_è¾“å‡º: Self::åˆå§‹åŒ–æƒé‡(éšè—ç»´åº¦, éšè—ç»´åº¦),
            å¤´æ•°: æ³¨æ„åŠ›å¤´æ•°,
            å¤´ç»´åº¦,
        }
    }
    
    fn åˆå§‹åŒ–æƒé‡(è¡Œæ•°: usize, åˆ—æ•°: usize) -> Vec<Vec<f32>> {
        let ç¼©æ”¾ = (2.0 / è¡Œæ•° as f32).sqrt();
        (0..è¡Œæ•°)
            .map(|_| {
                (0..åˆ—æ•°)
                    .map(|_| rand::random::<f32>() * ç¼©æ”¾ - ç¼©æ”¾ / 2.0)
                    .collect()
            })
            .collect()
    }
    
    pub fn å‰å‘ä¼ æ’­(&self, x: &[Vec<f32>], æ©ç : Option<&[Vec<bool>]>) -> Vec<Vec<f32>> {
        let åºåˆ—é•¿åº¦ = x.len();
        let éšè—ç»´åº¦ = x[0].len();
        
        // æŠ•å½±åˆ° Q, K, V
        let q = self.æŠ•å½±(&x, &self.æƒé‡_q);
        let k = self.æŠ•å½±(&x, &self.æƒé‡_k);
        let v = self.æŠ•å½±(&x, &self.æƒé‡_v);
        
        // é‡å¡‘ä¸ºå¤šå¤´
        let q_heads = self.é‡å¡‘å¤šå¤´(&q);
        let k_heads = self.é‡å¡‘å¤šå¤´(&k);
        let _v_heads = self.é‡å¡‘å¤šå¤´(&v);
        
        // è®¡ç®—æ³¨æ„åŠ›åˆ†æ•°
        let mut åˆ†æ•° = vec![vec![0.0; åºåˆ—é•¿åº¦]; åºåˆ—é•¿åº¦];
        let ç¼©æ”¾å› å­ = (self.å¤´ç»´åº¦ as f32).sqrt();
        
        for i in 0..åºåˆ—é•¿åº¦ {
            for j in 0..åºåˆ—é•¿åº¦ {
                // å› æœæ³¨æ„åŠ›ï¼šä¸å…³æ³¨æœªæ¥ä½ç½®
                if j > i {
                    åˆ†æ•°[i][j] = -1e10;
                } else {
                    let mut å¾—åˆ† = 0.0;
                    for h in 0..self.å¤´æ•° {
                        for d in 0..self.å¤´ç»´åº¦ {
                            å¾—åˆ† += q_heads[h][i][d] * k_heads[h][j][d];
                        }
                    }
                    åˆ†æ•°[i][j] = å¾—åˆ† / ç¼©æ”¾å› å­;
                }
            }
        }
        
        // åº”ç”¨æ©ç 
        if let Some(m) = æ©ç  {
            for i in 0..åºåˆ—é•¿åº¦ {
                for j in 0..åºåˆ—é•¿åº¦ {
                    if !m[i][j] {
                        åˆ†æ•°[i][j] = -1e10;
                    }
                }
            }
        }
        
        // Softmax
        let æ³¨æ„åŠ›æƒé‡ = self.softmax(&åˆ†æ•°);
        
        // åº”ç”¨æ³¨æ„åŠ›åˆ°å€¼
        let mut è¾“å‡º = vec![vec![0.0; éšè—ç»´åº¦]; åºåˆ—é•¿åº¦];
        for i in 0..åºåˆ—é•¿åº¦ {
            for j in 0..åºåˆ—é•¿åº¦ {
                let æƒé‡ = æ³¨æ„åŠ›æƒé‡[i][j];
                for d in 0..éšè—ç»´åº¦ {
                    è¾“å‡º[i][d] += æƒé‡ * v[j][d];
                }
            }
        }
        
        // è¾“å‡ºæŠ•å½±
        self.æŠ•å½±(&è¾“å‡º, &self.æƒé‡_è¾“å‡º)
    }
    
    fn æŠ•å½±(&self, x: &[Vec<f32>], æƒé‡: &[Vec<f32>]) -> Vec<Vec<f32>> {
        x.iter()
            .map(|è¡Œ| {
                æƒé‡.iter()
                    .map(|æƒé‡è¡Œ| {
                        è¡Œ.iter()
                            .zip(æƒé‡è¡Œ.iter())
                            .map(|(a, b)| a * b)
                            .sum()
                    })
                    .collect()
            })
            .collect()
    }
    
    fn é‡å¡‘å¤šå¤´(&self, x: &[Vec<f32>]) -> Vec<Vec<Vec<f32>>> {
        let åºåˆ—é•¿åº¦ = x.len();
        let mut å¤šå¤´ = vec![vec![vec![0.0; self.å¤´ç»´åº¦]; åºåˆ—é•¿åº¦]; self.å¤´æ•°];
        
        for i in 0..åºåˆ—é•¿åº¦ {
            for h in 0..self.å¤´æ•° {
                for d in 0..self.å¤´ç»´åº¦ {
                    å¤šå¤´[h][i][d] = x[i][h * self.å¤´ç»´åº¦ + d];
                }
            }
        }
        
        å¤šå¤´
    }
    
    fn softmax(&self, x: &[Vec<f32>]) -> Vec<Vec<f32>> {
        x.iter()
            .map(|è¡Œ| {
                let æœ€å¤§å€¼ = è¡Œ.iter().cloned().fold(f32::NEG_INFINITY, f32::max);
                let expå’Œ: f32 = è¡Œ.iter().map(|v| (v - æœ€å¤§å€¼).exp()).sum();
                è¡Œ.iter().map(|v| (v - æœ€å¤§å€¼).exp() / expå’Œ).collect()
            })
            .collect()
    }
}

/// Transformerå—
pub struct Transformerå— {
    æ³¨æ„åŠ›: æ³¨æ„åŠ›å¼•æ“,
    å‰é¦ˆç½‘ç»œ: å‰é¦ˆç¥ç»ç½‘ç»œ,
    è§„èŒƒåŒ–1: å±‚è§„èŒƒåŒ–,
    è§„èŒƒåŒ–2: å±‚è§„èŒƒåŒ–,
}

impl Transformerå— {
    pub fn æ–°å»º(é…ç½®: &GPTé…ç½®) -> Self {
        Self {
            æ³¨æ„åŠ›: æ³¨æ„åŠ›å¼•æ“::æ–°å»º(é…ç½®.éšè—å±‚ç»´åº¦, é…ç½®.æ³¨æ„åŠ›å¤´æ•°),
            å‰é¦ˆç½‘ç»œ: å‰é¦ˆç¥ç»ç½‘ç»œ::æ–°å»º(é…ç½®.éšè—å±‚ç»´åº¦),
            è§„èŒƒåŒ–1: å±‚è§„èŒƒåŒ–::æ–°å»º(é…ç½®.éšè—å±‚ç»´åº¦),
            è§„èŒƒåŒ–2: å±‚è§„èŒƒåŒ–::æ–°å»º(é…ç½®.éšè—å±‚ç»´åº¦),
        }
    }
    
    pub fn å‰å‘ä¼ æ’­(&self, x: &[Vec<f32>], æ©ç : Option<&[Vec<bool>]>) -> Vec<Vec<f32>> {
        // æ®‹å·® + æ³¨æ„åŠ›
        let x_norm = self.è§„èŒƒåŒ–1.å‰å‘ä¼ æ’­(x);
        let æ³¨æ„åŠ›è¾“å‡º = self.æ³¨æ„åŠ›.å‰å‘ä¼ æ’­(&x_norm, æ©ç );
        let x_æ®‹å·® = self.æ·»åŠ æ®‹å·®(x, &æ³¨æ„åŠ›è¾“å‡º);
        
        // æ®‹å·® + FFN
        let x_norm2 = self.è§„èŒƒåŒ–2.å‰å‘ä¼ æ’­(&x_æ®‹å·®);
        let ffnè¾“å‡º = self.å‰é¦ˆç½‘ç»œ.å‰å‘ä¼ æ’­(&x_norm2);
        self.æ·»åŠ æ®‹å·®(&x_æ®‹å·®, &ffnè¾“å‡º)
    }
    
    fn æ·»åŠ æ®‹å·®(&self, x: &[Vec<f32>], æ®‹å·®: &[Vec<f32>]) -> Vec<Vec<f32>> {
        x.iter()
            .zip(æ®‹å·®.iter())
            .map(|(xè¡Œ, rè¡Œ)| {
                xè¡Œ.iter()
                    .zip(rè¡Œ.iter())
                    .map(|(a, b)| a + b)
                    .collect()
            })
            .collect()
    }
}

/// å‰é¦ˆç¥ç»ç½‘ç»œ
pub struct å‰é¦ˆç¥ç»ç½‘ç»œ {
    æƒé‡1: Vec<Vec<f32>>,
    æƒé‡2: Vec<Vec<f32>>,
    åç½®1: Vec<f32>,
    åç½®2: Vec<f32>,
}

impl å‰é¦ˆç¥ç»ç½‘ç»œ {
    pub fn æ–°å»º(éšè—ç»´åº¦: usize) -> Self {
        let ä¸­é—´ç»´åº¦ = éšè—ç»´åº¦ * 4;
        
        Self {
            æƒé‡1: æ³¨æ„åŠ›å¼•æ“::åˆå§‹åŒ–æƒé‡(éšè—ç»´åº¦, ä¸­é—´ç»´åº¦),
            æƒé‡2: æ³¨æ„åŠ›å¼•æ“::åˆå§‹åŒ–æƒé‡(ä¸­é—´ç»´åº¦, éšè—ç»´åº¦),
            åç½®1: vec![0.0; ä¸­é—´ç»´åº¦],
            åç½®2: vec![0.0; éšè—ç»´åº¦],
        }
    }
    
    pub fn å‰å‘ä¼ æ’­(&self, x: &[Vec<f32>]) -> Vec<Vec<f32>> {
        x.iter()
            .map(|è¡Œ| {
                // ç¬¬ä¸€å±‚ä¸GELUæ¿€æ´»
                let éšè—å±‚: Vec<f32> = self.æƒé‡1.iter()
                    .zip(self.åç½®1.iter())
                    .map(|(æƒé‡è¡Œ, åç½®)| {
                        let å’Œ: f32 = è¡Œ.iter()
                            .zip(æƒé‡è¡Œ.iter())
                            .map(|(a, b)| a * b)
                            .sum::<f32>() + åç½®;
                        self.gelu(å’Œ)
                    })
                    .collect();
                
                // ç¬¬äºŒå±‚
                self.æƒé‡2.iter()
                    .zip(self.åç½®2.iter())
                    .map(|(æƒé‡è¡Œ, åç½®)| {
                        éšè—å±‚.iter()
                            .zip(æƒé‡è¡Œ.iter())
                            .map(|(a, b)| a * b)
                            .sum::<f32>() + åç½®
                    })
                    .collect()
            })
            .collect()
    }
    
    fn gelu(&self, x: f32) -> f32 {
        0.5 * x * (1.0 + ((2.0 / std::f32::consts::PI).sqrt() * (x + 0.044715 * x.powi(3))).tanh())
    }
}

/// å±‚è§„èŒƒåŒ–
pub struct å±‚è§„èŒƒåŒ– {
    gamma: Vec<f32>,
    beta: Vec<f32>,
    epsilon: f32,
}

impl å±‚è§„èŒƒåŒ– {
    pub fn æ–°å»º(ç»´åº¦: usize) -> Self {
        Self {
            gamma: vec![1.0; ç»´åº¦],
            beta: vec![0.0; ç»´åº¦],
            epsilon: 1e-5,
        }
    }
    
    pub fn å‰å‘ä¼ æ’­(&self, x: &[Vec<f32>]) -> Vec<Vec<f32>> {
        x.iter()
            .map(|è¡Œ| {
                let å‡å€¼: f32 = è¡Œ.iter().sum::<f32>() / è¡Œ.len() as f32;
                let æ–¹å·®: f32 = è¡Œ.iter()
                    .map(|v| (v - å‡å€¼).powi(2))
                    .sum::<f32>() / è¡Œ.len() as f32;
                
                è¡Œ.iter()
                    .zip(self.gamma.iter())
                    .zip(self.beta.iter())
                    .map(|((v, g), b)| {
                        ((v - å‡å€¼) / (æ–¹å·® + self.epsilon).sqrt()) * g + b
                    })
                    .collect()
            })
            .collect()
    }
}

/// ä¸­æ–‡GPTä¸»æ ¸å¿ƒ
pub struct ä¸­æ–‡GPTæ ¸å¿ƒ {
    pub é…ç½®: GPTé…ç½®,
    pub transformerå—: Vec<Transformerå—>,
    pub è¯åµŒå…¥: Vec<Vec<f32>>,
    pub ä½ç½®åµŒå…¥: Vec<Vec<f32>>,
    pub æœ€ç»ˆè§„èŒƒåŒ–: å±‚è§„èŒƒåŒ–,
    pub è¯­è¨€æ¨¡å‹å¤´: Vec<Vec<f32>>,
    pub æƒ…æ„ŸçŠ¶æ€: æƒ…æ„ŸçŠ¶æ€,
    pub ä¸Šä¸‹æ–‡ç¼“å†²: VecDeque<Vec<f32>>,
}

impl ä¸­æ–‡GPTæ ¸å¿ƒ {
    pub fn æ–°å»º(é…ç½®: GPTé…ç½®) -> Self {
        let mut transformerå— = Vec::new();
        for _ in 0..é…ç½®.å±‚æ•° {
            transformerå—.push(Transformerå—::æ–°å»º(&é…ç½®));
        }
        
        Self {
            transformerå—,
            è¯åµŒå…¥: Self::åˆå§‹åŒ–åµŒå…¥(
                é…ç½®.è¯æ±‡é‡å¤§å°,
                é…ç½®.éšè—å±‚ç»´åº¦
            ),
            ä½ç½®åµŒå…¥: Self::åˆå§‹åŒ–åµŒå…¥(
                é…ç½®.ä¸Šä¸‹æ–‡é•¿åº¦,
                é…ç½®.éšè—å±‚ç»´åº¦
            ),
            æœ€ç»ˆè§„èŒƒåŒ–: å±‚è§„èŒƒåŒ–::æ–°å»º(é…ç½®.éšè—å±‚ç»´åº¦),
            è¯­è¨€æ¨¡å‹å¤´: æ³¨æ„åŠ›å¼•æ“::åˆå§‹åŒ–æƒé‡(é…ç½®.éšè—å±‚ç»´åº¦, é…ç½®.è¯æ±‡é‡å¤§å°),
            æƒ…æ„ŸçŠ¶æ€: æƒ…æ„ŸçŠ¶æ€::default(),
            ä¸Šä¸‹æ–‡ç¼“å†²: VecDeque::with_capacity(é…ç½®.ä¸Šä¸‹æ–‡é•¿åº¦),
            é…ç½®,
        }
    }
    
    fn åˆå§‹åŒ–åµŒå…¥(æ•°é‡: usize, ç»´åº¦: usize) -> Vec<Vec<f32>> {
        (0..æ•°é‡)
            .map(|_| {
                (0..ç»´åº¦)
                    .map(|_| rand::random::<f32>() * 0.02 - 0.01)
                    .collect()
            })
            .collect()
    }
    
    pub fn å‰å‘ä¼ æ’­(&mut self, ä»¤ç‰Œ: &[usize]) -> Result<Vec<Vec<f32>>> {
        let _åºåˆ—é•¿åº¦ = ä»¤ç‰Œ.len();
        
        // ä»¤ç‰ŒåµŒå…¥ + ä½ç½®åµŒå…¥
        let mut x: Vec<Vec<f32>> = Vec::new();
        for (i, &token) in ä»¤ç‰Œ.iter().enumerate() {
            let mut åµŒå…¥ = self.è¯åµŒå…¥[token].clone();
            for j in 0..self.é…ç½®.éšè—å±‚ç»´åº¦ {
                åµŒå…¥[j] += self.ä½ç½®åµŒå…¥[i][j];
            }
            x.push(åµŒå…¥);
        }
        
        // åº”ç”¨æƒ…æ„Ÿè°ƒèŠ‚çš„dropout
        x = self.åº”ç”¨æƒ…æ„Ÿdropout(x);
        
        // é€šè¿‡transformerå—
        for å— in &self.transformerå— {
            x = å—.å‰å‘ä¼ æ’­(&x, None);
        }
        
        // æœ€ç»ˆè§„èŒƒåŒ–
        x = self.æœ€ç»ˆè§„èŒƒåŒ–.å‰å‘ä¼ æ’­(&x);
        
        // è¯­è¨€æ¨¡å‹å¤´
        let logits = self.åº”ç”¨è¯­è¨€æ¨¡å‹å¤´(&x);
        
        // æ›´æ–°ä¸Šä¸‹æ–‡
        self.æ›´æ–°ä¸Šä¸‹æ–‡(&x);
        
        Ok(logits)
    }
    
    fn åº”ç”¨æƒ…æ„Ÿdropout(&self, mut x: Vec<Vec<f32>>) -> Vec<Vec<f32>> {
        let æƒ…æ„Ÿå¼ºåº¦ = self.æƒ…æ„ŸçŠ¶æ€.æ¿€æ´»åº¦ * (1.0 - self.æƒ…æ„ŸçŠ¶æ€.å«è“„åº¦);
        let ä¿ç•™æ¦‚ç‡ = 1.0 - (self.é…ç½®.dropoutç‡ * (1.0 - æƒ…æ„Ÿå¼ºåº¦));
        
        for è¡Œ in &mut x {
            for å€¼ in è¡Œ {
                if rand::random::<f32>() > ä¿ç•™æ¦‚ç‡ {
                    *å€¼ = 0.0;
                }
            }
        }
        
        x
    }
    
    fn åº”ç”¨è¯­è¨€æ¨¡å‹å¤´(&self, x: &[Vec<f32>]) -> Vec<Vec<f32>> {
        x.iter()
            .map(|è¡Œ| {
                self.è¯­è¨€æ¨¡å‹å¤´.iter()
                    .map(|æƒé‡è¡Œ| {
                        è¡Œ.iter()
                            .zip(æƒé‡è¡Œ.iter())
                            .map(|(a, b)| a * b)
                            .sum()
                    })
                    .collect()
            })
            .collect()
    }
    
    fn æ›´æ–°ä¸Šä¸‹æ–‡(&mut self, x: &[Vec<f32>]) {
        for è¡Œ in x {
            self.ä¸Šä¸‹æ–‡ç¼“å†².push_back(è¡Œ.clone());
            if self.ä¸Šä¸‹æ–‡ç¼“å†².len() > self.é…ç½®.ä¸Šä¸‹æ–‡é•¿åº¦ {
                self.ä¸Šä¸‹æ–‡ç¼“å†².pop_front();
            }
        }
    }
    
    pub fn ç”Ÿæˆ(&mut self, æç¤º: &[usize], æœ€å¤§ä»¤ç‰Œæ•°: usize) -> Result<Vec<usize>> {
        let mut ä»¤ç‰Œ = æç¤º.to_vec();
        
        for _ in 0..æœ€å¤§ä»¤ç‰Œæ•° {
            let logits = self.å‰å‘ä¼ æ’­(&ä»¤ç‰Œ)?;
            let ä¸‹ä¸€ä¸ªä»¤ç‰Œ = self.æƒ…æ„Ÿé‡‡æ ·(&logits[logits.len() - 1]);
            ä»¤ç‰Œ.push(ä¸‹ä¸€ä¸ªä»¤ç‰Œ);
        }
        
        Ok(ä»¤ç‰Œ)
    }
    
    fn æƒ…æ„Ÿé‡‡æ ·(&self, logits: &[f32]) -> usize {
        // åŸºäºæƒ…æ„ŸçŠ¶æ€è°ƒæ•´æ¸©åº¦
        let æ¸©åº¦ = self.é…ç½®.æƒ…æ„Ÿæ¸©åº¦ * 
                   (1.0 + self.æƒ…æ„ŸçŠ¶æ€.å’Œè°æ€§ * 0.3) *
                   (1.0 - self.æƒ…æ„ŸçŠ¶æ€.å«è“„åº¦ * 0.2);
        
        // åº”ç”¨æ¸©åº¦å’Œsoftmax
        let æœ€å¤§logit = logits.iter().cloned().fold(f32::NEG_INFINITY, f32::max);
        let exp_logits: Vec<f32> = logits.iter()
            .map(|l| ((l - æœ€å¤§logit) / æ¸©åº¦).exp())
            .collect();
        let æ€»å’Œ: f32 = exp_logits.iter().sum();
        let æ¦‚ç‡: Vec<f32> = exp_logits.iter().map(|e| e / æ€»å’Œ).collect();
        
        // é‡‡æ ·
        let mut éšæœºå€¼ = rand::random::<f32>();
        for (i, &æ¦‚ç‡å€¼) in æ¦‚ç‡.iter().enumerate() {
            éšæœºå€¼ -= æ¦‚ç‡å€¼;
            if éšæœºå€¼ <= 0.0 {
                return i;
            }
        }
        
        æ¦‚ç‡.len() - 1
    }
    
    pub fn æ›´æ–°æƒ…æ„Ÿ(&mut self, æ–°æƒ…æ„Ÿ: æƒ…æ„ŸçŠ¶æ€) {
        // ä¸å½“å‰çŠ¶æ€æ··åˆä»¥å®ç°å¹³æ»‘è¿‡æ¸¡
        self.æƒ…æ„ŸçŠ¶æ€.ä»·å€¼æ€§ = 
            self.æƒ…æ„ŸçŠ¶æ€.ä»·å€¼æ€§ * 0.7 + æ–°æƒ…æ„Ÿ.ä»·å€¼æ€§ * 0.3;
        self.æƒ…æ„ŸçŠ¶æ€.æ¿€æ´»åº¦ = 
            self.æƒ…æ„ŸçŠ¶æ€.æ¿€æ´»åº¦ * 0.7 + æ–°æƒ…æ„Ÿ.æ¿€æ´»åº¦ * 0.3;
        self.æƒ…æ„ŸçŠ¶æ€.ä¸»å¯¼æ€§ = 
            self.æƒ…æ„ŸçŠ¶æ€.ä¸»å¯¼æ€§ * 0.7 + æ–°æƒ…æ„Ÿ.ä¸»å¯¼æ€§ * 0.3;
        self.æƒ…æ„ŸçŠ¶æ€.å«è“„åº¦ = 
            self.æƒ…æ„ŸçŠ¶æ€.å«è“„åº¦ * 0.6 + æ–°æƒ…æ„Ÿ.å«è“„åº¦ * 0.4;
        self.æƒ…æ„ŸçŠ¶æ€.å’Œè°æ€§ = 
            self.æƒ…æ„ŸçŠ¶æ€.å’Œè°æ€§ * 0.6 + æ–°æƒ…æ„Ÿ.å’Œè°æ€§ * 0.4;
    }
}

// å…¬å¼€å¯¼å‡º
pub use self::{
    GPTé…ç½® as ChineseGPTConfig,
    æƒ…æ„ŸçŠ¶æ€ as ChineseEmotionalState,
    ä¸­æ–‡GPTæ ¸å¿ƒ as ChineseGPTCore,
};